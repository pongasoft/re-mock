/*
 * Copyright (c) 2021 pongasoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * @author Yan Pujante
 */

#include <re/mock/Rack.h>
#include <re/mock/MockDevices.h>
#include <gtest/gtest.h>
#include <re/mock/MockJukebox.h>

namespace re::mock::Test {

using namespace mock;

// Transport.Usage
TEST(Transport, Usage)
{
  Transport transport{44100};

  ASSERT_EQ(0, transport.getPlayPos());
  ASSERT_EQ(44, transport.getPlayBatchEndPos());

  transport.setLoopEnabled(true);
  transport.setLoopStartPos(200);
  transport.setLoopEndPos(20);

  ASSERT_EQ(0, transport.getPlayPos());
  ASSERT_EQ(224, transport.getPlayBatchEndPos());

  transport.setLoopEnabled(false);
  ASSERT_EQ(0, transport.getPlayPos());
  ASSERT_EQ(44, transport.getPlayBatchEndPos());

}

//------------------------------------------------------------------------
// TransportTester
//------------------------------------------------------------------------
struct TransportTester
{
  int fSampleRate{44100};
  TJBox_Float64 fTempo{120};
  sequencer::Time fStart{};
  bool fLoopEnabled{};
  sequencer::Time fLoopStart{};
  sequencer::Time fLoopEnd{};

  TransportTester &sampleRate(int iSampleRate) { fSampleRate = iSampleRate; return *this; }
  TransportTester &tempo(TJBox_Float64 iTempo) { fTempo = iTempo; return *this; }
  TransportTester &start(sequencer::Time iTime) { fStart = iTime; return *this; }
  TransportTester &loop(sequencer::Time iLoopStart, sequencer::Time iLoopEnd) { fLoopEnabled = true; fLoopStart = iLoopStart; fLoopEnd = iLoopEnd; return *this; }

  Transport createTransport() const
  {
    Transport transport{fSampleRate};

    transport.setPlaying(true);
    transport.setSongEndPos(1000000);
    transport.setTempo(fTempo);
    transport.setLoopStartPos(fLoopStart.toPPQCount());
    transport.setLoopEndPos(fLoopEnd.toPPQCount());
    transport.setPlayPos(fStart.toPPQCount());
    transport.setLoopEnabled(fLoopEnabled);

    return transport;
  }

  void check(std::vector<int> iExpected, bool iWarnOnly = false) const
  {
    Transport t = createTransport();

    for(int i = 0; i < iExpected.size(); i++)
    {
      if(iExpected[i] !=  t.getPlayPos())
      {
        RE_MOCK_LOG_WARNING("[%d] %d!=%d", i, iExpected[i], t.getPlayPos());
      }
      if(!iWarnOnly)
        ASSERT_EQ(iExpected[i], t.getPlayPos());
      t.nextBatch();
    }
  }

  void check(int iIndex, int iExpected) const
  {
    ASSERT_EQ(iExpected, getTransportAt(iIndex).getPlayPos());
  }

  Transport getTransportAt(int iIndex) const
  {
    Transport t = createTransport();

    for(int i = 0; i < iIndex; i++)
      t.nextBatch();

    return t;
  }
};

// Transport.nextBatch
TEST(Transport, nextBatch)
{
  auto start = sequencer::Time(2,1,1,0);

  // the expected data has been generated by Reason for batch [0 .. 150]
  std::vector<int> expected_44100_99 = {
    0, 37, 73, 110, 147, 184, 221, 257, 294, 331, 368, 405, 441, 478, 515, 552, 588, 625, 662, 699, 736, 772, 809, 846,
    883, 919, 956, 993, 1030, 1067, 1103, 1140, 1177, 1214, 1250, 1287, 1324, 1361, 1398, 1434, 1471, 1508, 1545, 1581,
    1618, 1655, 1692, 1729, 1765, 1802, 1839, 1876, 1913, 1949, 1986, 2023, 2060, 2096, 2133, 2170, 2207, 2244, 2280,
    2317, 2354, 2391, 2427, 2464, 2501, 2538, 2575, 2611, 2648, 2685, 2722, 2758, 2795, 2832, 2869, 2906, 2942, 2979,
    3016, 3053, 3089, 3126, 3163, 3200, 3237, 3273, 3310, 3347, 3384, 3421, 3457, 3494, 3531, 3568, 3604, 3641, 3678,
  };

  TransportTester{}.sampleRate(44100).tempo(99)
    .check(expected_44100_99);

  std::vector<int> expected_44100_120 = {
    0, 44, 89, 134, 178, 223, 267, 312, 356, 401, 446, 490, 535, 579, 624, 669, 713, 758, 802, 847, 891, 936, 981, 1025,
    1070, 1114, 1159, 1204, 1248, 1293, 1337, 1382, 1426, 1471, 1516, 1560, 1605, 1649, 1694, 1739, 1783, 1828, 1872,
    1917, 1961, 2006, 2051, 2095, 2140, 2184, 2229, 2274, 2318, 2363, 2407, 2452, 2496, 2541, 2586, 2630, 2675, 2719,
    2764, 2808, 2853, 2898, 2942, 2987, 3031, 3076, 3121, 3165, 3210, 3254, 3299, 3343, 3388, 3433, 3477, 3522, 3566,
    3611, 3656, 3700, 3745, 3789, 3834, 3878, 3923, 3968, 4012, 4057, 4101, 4146, 4191, 4235, 4280, 4324, 4369, 4413,
    4458,
  };

  TransportTester{}.sampleRate(44100).tempo(120)
    .check(expected_44100_120);

  std::vector<int> expected_44100_161 = {
    0, 59, 119, 179, 239, 299, 358, 418, 478, 538, 598, 658, 717, 777, 837, 897, 957, 1016, 1076, 1136, 1196, 1256,
    1315, 1375, 1435, 1495, 1555, 1615, 1674, 1734, 1794, 1854, 1914, 1973, 2033, 2093, 2153, 2213, 2273, 2332, 2392,
    2452, 2512, 2572, 2631, 2691, 2751, 2811, 2871, 2930, 2990, 3050, 3110, 3170, 3230, 3289, 3349, 3409, 3469, 3529,
    3588, 3648, 3708, 3768, 3828, 3888, 3947, 4007, 4067, 4127, 4187, 4246, 4306, 4366, 4426, 4486, 4545, 4605, 4665,
    4725, 4785, 4845, 4904, 4964, 5024, 5084, 5144, 5203, 5263, 5323, 5383, 5443, 5503, 5562, 5622, 5682, 5742, 5802,
    5861, 5921, 5981,
  };

  TransportTester{}.sampleRate(44100).tempo(161)
    .check(expected_44100_161);

  std::vector<int> expected_48000_99 = {
    0, 34, 68, 101, 135, 169, 203, 237, 270, 304, 338, 372, 405, 439, 473, 507, 541, 574, 608, 642, 676, 710, 743, 777,
    811, 845, 879, 912, 946, 980, 1014, 1048, 1081, 1115, 1149, 1183, 1216, 1250, 1284, 1318, 1352, 1385, 1419, 1453,
    1487, 1521, 1554, 1588, 1622, 1656, 1690, 1723, 1757, 1791, 1825, 1859, 1892, 1926, 1960, 1994, 2027, 2061, 2095,
    2129, 2163, 2196, 2230, 2264, 2298, 2332, 2365, 2399, 2433, 2467, 2501, 2534, 2568, 2602, 2636, 2670, 2703, 2737,
    2771, 2805, 2839, 2872, 2906, 2940, 2974, 3007, 3041, 3075, 3109, 3143, 3176, 3210, 3244, 3278, 3312, 3345, 3379,
    3413, 3447, 3481, 3514, 3548, 3582, 3616, 3650, 3683, 3717, 3751, 3785, 3818, 3852, 3886, 3920, 3954, 3987, 4021,
    4055, 4089, 4123, 4156, 4190, 4224, 4258, 4292, 4325, 4359, 4393, 4427, 4461, 4494, 4528, 4562, 4596, 4629, 4663,
    4697, 4731, 4765, 4798, 4832, 4866, 4900, 4934, 4967, 5001, 5035, 5069,
  };

  TransportTester{}.sampleRate(48000).tempo(99)
    .check(expected_48000_99);

  std::vector<int> expected_48000_120 = {
    0, 41, 82, 123, 164, 205, 246, 287, 328, 369, 409, 450, 491, 532, 573, 614, 655, 696, 737, 778, 819, 860, 901, 942,
    983, 1024, 1065, 1106, 1147, 1188, 1229, 1270, 1311, 1352, 1393, 1433, 1474, 1515, 1556, 1597, 1638, 1679, 1720,
    1761, 1802, 1843, 1884, 1925, 1966, 2007, 2048, 2089, 2130, 2171, 2212, 2253, 2294, 2335, 2376, 2417, 2457, 2498,
    2539, 2580, 2621, 2662, 2703, 2744, 2785, 2826, 2867, 2908, 2949, 2990, 3031, 3072, 3113, 3154, 3195, 3236, 3277,
    3318, 3359, 3400, 3441, 3481, 3522, 3563, 3604, 3645, 3686, 3727, 3768, 3809, 3850, 3891, 3932, 3973, 4014, 4055,
    4096,
  };

  TransportTester{}.sampleRate(48000).tempo(120)
    .check(expected_48000_120);

  std::vector<int> expected_48000_120_61440 = {
    61440, 61481, 61522, 61563, 61604, 61645, 61686, 61727, 61768, 61809, 61849, 61890, 61931, 61972, 62013, 62054,
    62095, 62136, 62177, 62218, 62259, 62300, 62341, 62382, 62423, 62464, 62505, 62546, 62587, 62628, 62669, 62710,
    62751, 62792, 62833, 62873, 62914, 62955, 62996, 63037, 63078, 63119, 63160, 63201, 63242, 63283, 63324, 63365,
    63406, 63447, 63488, 63529, 63570, 63611, 63652, 63693, 63734, 63775, 63816, 63857, 63897, 63938, 63979, 64020,
    64061, 64102, 64143, 64184, 64225, 64266, 64307, 64348, 64389, 64430, 64471, 64512, 64553, 64594, 64635, 64676,
    64717, 64758, 64799, 64840, 64881, 64921, 64962, 65003, 65044, 65085, 65126, 65167, 65208, 65249, 65290, 65331,
    65372, 65413, 65454, 65495, 65536, 65577, 65618, 65659, 65700, 65741, 65782, 65823, 65864, 65905, 65945, 65986,
    66027, 66068, 66109, 66150, 66191, 66232, 66273, 66314, 66355, 66396, 66437, 66478, 66519, 66560, 66601, 66642,
    66683, 66724, 66765, 66806, 66847, 66888, 66929, 66969, 67010, 67051, 67092, 67133, 67174, 67215, 67256, 67297,
    67338, 67379, 67420, 67461, 67502, 67543, 67584
  };

  TransportTester{}.sampleRate(48000).tempo(120).start(start)
    .check(expected_48000_120_61440);

  std::vector<int> expected_48000_121 = {
    0, 41, 82, 124, 165, 206, 248, 289, 330, 372, 413, 454, 495, 537, 578, 619, 661, 702, 743, 785, 826, 867, 908, 950,
    991, 1032, 1074, 1115, 1156, 1198, 1239, 1280, 1321, 1363, 1404, 1445, 1487, 1528, 1569, 1611, 1652, 1693, 1735,
    1776, 1817, 1858, 1900, 1941, 1982, 2024, 2065, 2106, 2148, 2189, 2230, 2271, 2313, 2354, 2395, 2437, 2478, 2519,
    2561, 2602, 2643, 2684, 2726, 2767, 2808, 2850, 2891, 2932, 2974, 3015, 3056, 3097, 3139, 3180, 3221, 3263, 3304,
    3345, 3387, 3428, 3469, 3510, 3552, 3593, 3634, 3676, 3717, 3758, 3800, 3841, 3882, 3923, 3965, 4006, 4047, 4089,
    4130, 4171, 4213, 4254, 4295, 4336, 4378, 4419, 4460, 4502, 4543, 4584, 4626, 4667, 4708, 4750, 4791, 4832, 4873,
    4915, 4956, 4997, 5039, 5080, 5121, 5163, 5204, 5245, 5286, 5328, 5369, 5410, 5452, 5493, 5534, 5576, 5617, 5658,
    5699, 5741, 5782, 5823, 5865, 5906, 5947, 5989, 6030, 6071, 6112, 6154, 6195
  };

  TransportTester{}.sampleRate(48000).tempo(121)
    .check(expected_48000_121);


  std::vector<int> expected_48000_200 = {
    0, 68, 136, 204, 273, 341, 409, 477, 546, 614, 682, 750, 819, 887, 955, 1023, 1092, 1160, 1228, 1297, 1365, 1433,
    1501, 1570, 1638, 1706, 1774, 1843, 1911, 1979, 2047, 2116, 2184, 2252, 2321, 2389, 2457, 2525, 2594, 2662, 2730,
    2798, 2867, 2935, 3003, 3071, 3140, 3208, 3276, 3345, 3413, 3481, 3549, 3618, 3686, 3754, 3822, 3891, 3959, 4027,
    4095, 4164, 4232, 4300, 4369, 4437, 4505, 4573, 4642, 4710, 4778, 4846, 4915, 4983, 5051, 5119, 5188, 5256, 5324,
    5393, 5461, 5529, 5597, 5666, 5734, 5802, 5870, 5939, 6007, 6075, 6143, 6212, 6280, 6348, 6417, 6485, 6553, 6621,
    6690, 6758, 6826, 6894, 6963, 7031, 7099, 7167, 7236, 7304, 7372, 7441, 7509, 7577, 7645, 7714, 7782, 7850, 7918,
    7987, 8055, 8123, 8191, 8260, 8328, 8396, 8465, 8533, 8601, 8669, 8738, 8806, 8874, 8942, 9011, 9079, 9147, 9215,
    9284, 9352, 9420, 9489, 9557, 9625, 9693, 9762, 9830, 9898, 9966, 10035, 10103, 10171, 10239
  };

  TransportTester{}.sampleRate(48000).tempo(200)
    .check(expected_48000_200);

}

// Transport.nextBatchFailing TODO fix
TEST(Transport, nextBatchFailing)
{
  // This test reveals that there is an offset used when not starting at 0

  // Implementation note: I have spent more than a week trying to reverse engineer the formula that computes play_pos
  // and despite all my best efforts, I can still find a use case that fails: when the sequencer starts at 0 it works
  // fine and produces the right set of play_pos but when it starts at 61440 the reset is not just offset. I don't
  // understand what I am doing wrong... So for now, it will have to wait...

  // Update: 2022/01/11: "One thing I found that might help is that the PPQ position calculations are not only
  // done using float/double - the step forward for each batch goes via / is truncated to fixed point integers
  // with decimals in 7 bits, i.e. 1.0 == 128.
  //
  // The doc says this is part of the design, to get deterministic and equal step forward in fractional PPQ
  // between different sequencers which are at different absolute positions. I guess this means sequencers
  // within rack devices, but maybe also components of the main sequencer in Reason stand-alone."

  std::vector<int> expected_48000_99_0 = {
    0, 34, 68, 101, 135, 169, 203, 237, 270, 304, 338, 372, 405, 439, 473, 507, 541, 574, 608, 642, 676, 710, 743, 777,
    811, 845, 879, 912, 946, 980, 1014, 1048, 1081, 1115, 1149, 1183, 1216, 1250, 1284, 1318, 1352, 1385, 1419, 1453,
    1487, 1521, 1554, 1588, 1622, 1656, 1690, 1723, 1757, 1791, 1825, 1859, 1892, 1926, 1960, 1994, 2027, 2061, 2095,
    2129, 2163, 2196, 2230, 2264, 2298, 2332, 2365, 2399, 2433, 2467, 2501, 2534, 2568, 2602, 2636, 2670, 2703, 2737,
    2771, 2805, 2839, 2872, 2906, 2940, 2974, 3007, 3041, 3075, 3109, 3143, 3176, 3210, 3244, 3278, 3312, 3345, 3379,
    3413, 3447, 3481, 3514, 3548, 3582, 3616, 3650, 3683, 3717, 3751, 3785, 3818, 3852, 3886, 3920, 3954, 3987, 4021,
    4055, 4089, 4123, 4156, 4190, 4224, 4258, 4292, 4325, 4359, 4393, 4427, 4461, 4494, 4528, 4562, 4596, 4629, 4663,
    4697, 4731, 4765, 4798, 4832, 4866, 4900, 4934, 4967, 5001, 5035, 5069,
  };

  TransportTester{}.sampleRate(48000).tempo(99)
    .check(expected_48000_99_0);

  std::vector<int> expected_48900_99_61440 = {
    61440, 61474, 61508, 61542, 61575, 61609, 61643, 61677, 61711, 61744, 61778, 61812, 61846, 61879, 61913, 61947,
    61981, 62015, 62048, 62082, 62116, 62150, 62184, 62217, 62251, 62285, 62319, 62353, 62386, 62420, 62454, 62488,
    62522, 62555, 62589, 62623, 62657, 62690, 62724, 62758, 62792, 62826, 62859, 62893, 62927, 62961, 62995, 63028,
    63062, 63096, 63130, 63164, 63197, 63231, 63265, 63299, 63333, 63366, 63400, 63434, 63468, 63501, 63535, 63569,
    63603, 63637, 63670, 63704, 63738, 63772, 63806, 63839, 63873, 63907, 63941, 63975, 64008, 64042, 64076, 64110,
    64144, 64177, 64211, 64245, 64279, 64312, 64346, 64380, 64414, 64448, 64481, 64515, 64549, 64583, 64617, 64650,
    64684, 64718, 64752, 64786, 64819, 64853, 64887, 64921, 64955, 64988, 65022, 65056, 65090, 65123, 65157, 65191,
    65225, 65259, 65292, 65326, 65360, 65394, 65428, 65461, 65495, 65529, 65563, 65597, 65630, 65664, 65698, 65732,
    65766, 65799, 65833, 65867, 65901, 65935, 65968, 66002, 66036, 66070, 66103, 66137, 66171, 66205, 66239, 66272,
    66306, 66340, 66374, 66408, 66441, 66475, 66509
  };

  // Computed fFactor is 0.472. With 0.664 it works (+ 0.192)
  TransportTester{}.sampleRate(48000).tempo(99).start(sequencer::Time(2,1,1,0))
    .check(expected_48900_99_61440, true);

  std::vector<int> expected_48900_73_61440 = {
    61440, 61465, 61490, 61515, 61540, 61565, 61590, 61615, 61640, 61665, 61690, 61715, 61739, 61764, 61789, 61814,
    61839, 61864, 61889, 61914, 61939, 61964, 61989, 62014, 62038, 62063, 62088, 62113, 62138, 62163, 62188, 62213,
    62238, 62263, 62288, 62313, 62337, 62362, 62387, 62412, 62437, 62462, 62487, 62512, 62537, 62562, 62587, 62612,
    62636, 62661, 62686, 62711, 62736, 62761, 62786, 62811, 62836, 62861, 62886, 62911, 62935, 62960, 62985, 63010,
    63035, 63060, 63085, 63110, 63135, 63160, 63185, 63210, 63234, 63259, 63284, 63309, 63334, 63359, 63384, 63409,
    63434, 63459, 63484, 63509, 63533, 63558, 63583, 63608, 63633, 63658, 63683, 63708, 63733, 63758, 63783, 63808,
    63832, 63857, 63882, 63907, 63932, 63957, 63982, 64007, 64032, 64057, 64082, 64107, 64131, 64156, 64181, 64206,
    64231, 64256, 64281, 64306, 64331, 64356, 64381, 64406, 64430, 64455, 64480, 64505, 64530, 64555, 64580, 64605,
    64630, 64655, 64680, 64705, 64730, 64754, 64779, 64804, 64829, 64854, 64879, 64904, 64929, 64954, 64979, 65004,
    65029, 65053, 65078, 65103, 65128, 65153, 65178
  };

  // Computed fFactor is 0.6106666. With 0.915666 it works (+ 0.305)
  TransportTester{}.sampleRate(48000).tempo(73).start(sequencer::Time(2,1,1,0))
    .check(expected_48900_73_61440, true);

  std::vector<int> expected_48000_121_61440 = {
    61440, 61481, 61523, 61564, 61605, 61647, 61688, 61729, 61771, 61812, 61853, 61894, 61936, 61977, 62018, 62060,
    62101, 62142, 62184, 62225, 62266, 62307, 62349, 62390, 62431, 62473, 62514, 62555, 62597, 62638, 62679, 62720,
    62762, 62803, 62844, 62886, 62927, 62968, 63010, 63051, 63092, 63133, 63175, 63216, 63257, 63299, 63340, 63381,
    63423, 63464, 63505, 63546, 63588, 63629, 63670, 63712, 63753, 63794, 63836, 63877, 63918, 63959, 64001, 64042,
    64083, 64125, 64166, 64207, 64249, 64290, 64331, 64373, 64414, 64455, 64496, 64538, 64579, 64620, 64662, 64703,
    64744, 64786, 64827, 64868, 64909, 64951, 64992, 65033, 65075, 65116, 65157, 65199, 65240, 65281, 65322, 65364,
    65405, 65446, 65488, 65529, 65570, 65612, 65653, 65694, 65735, 65777, 65818, 65859, 65901, 65942, 65983, 66025,
    66066, 66107, 66148, 66190, 66231, 66272, 66314, 66355, 66396, 66438, 66479, 66520, 66561, 66603, 66644, 66685,
    66727, 66768, 66809, 66851, 66892, 66933, 66974, 67016, 67057, 67098, 67140, 67181, 67222, 67264, 67305, 67346,
    67387, 67429, 67470, 67511, 67553, 67594, 67635
  };

  TransportTester{}.sampleRate(48000).tempo(121).start(sequencer::Time(2,1,1,0))
    .check(expected_48000_121_61440, true);
}

// Transport.nextBatchWithLoopingForward
TEST(Transport, nextBatchWithLoopingForward)
{
  // the expected data has been generated by Reason for batch [0 .. 150]
  std::vector<int> expected_44800_187_5 = {
    0, 64, 128, 192, 256, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 3903, 3967, 4031, 4095, 4159, 4223,
    4287, 4351, 4415, 4479, 4543, 4607, 4671, 4735, 4799, 4863, 4927, 4991, 5055, 5119, 5183, 5247, 5311, 5375, 5439,
    5503, 5567, 5631, 5695, 5759, 5823, 5887, 5951, 6015, 6079, 6143, 6207, 6271, 6335, 6399, 6463, 6527, 6591, 6655,
    6719, 6783, 6847, 6911, 6975, 7039, 7103, 7167, 7231, 7295, 7359, 7423, 7487, 7551, 7615, 7679, 7743, 7807, 7871,
    7935, 7999, 8063, 8127, 8191, 8255, 8319, 8383, 8447, 8511, 8575, 8639, 8703, 8767, 8831, 8895, 8959, 9023, 9087,
    9151, 9215, 9279, 9343, 9407, 9471, 9535, 9599, 9663, 9727, 9791, 9855, 9919, 9983, 10047, 10111, 10175, 10239,
    10303, 10367, 10431, 10495, 10559, 10623, 10687, 10751, 10815, 10879, 10943, 11007, 11071, 11135, 11199, 11263,
    11327, 11391, 11455, 11519, 11583, 11647, 11711, 11775, 11839, 11903, 11967, 12031, 12095, 12159, 12223, 12287,
    12351, 12415, 12479
  };
  // 1000: 66879
  // 10000: 642879

  // 187.5 at 48000 => 1 sample == 1 ppq (with non round math)
  TransportTester{}.sampleRate(48000).tempo(187.5).loop(sequencer::Time(1,1,2,0), sequencer::Time(1,1,1,60))
    .check(expected_44800_187_5);

  std::vector<int> expected_44800_140_625 = {
    0, 48, 96, 144, 192, 240, 288, 336, 384, 432, 480, 528, 576, 624, 672, 720, 768, 816, 864, 912, 960, 3887, 3935,
    3983, 4031, 4079, 4127, 4175, 4223, 4271, 4319, 4367, 4415, 4463, 4511, 4559, 4607, 4655, 4703, 4751, 4799, 4847,
    4895, 4943, 4991, 5039, 5087, 5135, 5183, 5231, 5279, 5327, 5375, 5423, 5471, 5519, 5567, 5615, 5663, 5711, 5759,
    5807, 5855, 5903, 5951, 5999, 6047, 6095, 6143, 6191, 6239, 6287, 6335, 6383, 6431, 6479, 6527, 6575, 6623, 6671,
    6719, 6767, 6815, 6863, 6911, 6959, 7007, 7055, 7103, 7151, 7199, 7247, 7295, 7343, 7391, 7439, 7487, 7535, 7583,
    7631, 7679, 7727, 7775, 7823, 7871, 7919, 7967, 8015, 8063, 8111, 8159, 8207, 8255, 8303, 8351, 8399, 8447, 8495,
    8543, 8591, 8639, 8687, 8735, 8783, 8831, 8879, 8927, 8975, 9023, 9071, 9119, 9167, 9215, 9263, 9311, 9359, 9407,
    9455, 9503, 9551, 9599, 9647, 9695, 9743, 9791, 9839, 9887, 9935, 9983, 10031, 10079
  };
  // 1000: 50879
  // 10000: 482879

  // 140.625 at 48000 => 1 sample == 0.75 ppq (with round math)
  TransportTester{}.sampleRate(48000).tempo(140.625).loop(sequencer::Time(1,1,2,0), sequencer::Time(1,1,1,60))
    .check(expected_44800_140_625);

  std::vector<int> expected_44800_120 = {
    0, 41, 82, 123, 164, 205, 246, 287, 328, 369, 409, 450, 491, 532, 573, 614, 655, 696, 737, 778, 819, 860, 901, 942,
    3863, 3904, 3945, 3986, 4027, 4068, 4109, 4150, 4191, 4232, 4273, 4313, 4354, 4395, 4436, 4477, 4518, 4559, 4600,
    4641, 4682, 4723, 4764, 4805, 4846, 4887, 4928, 4969, 5010, 5051, 5092, 5133, 5174, 5215, 5256, 5297, 5337, 5378,
    5419, 5460, 5501, 5542, 5583, 5624, 5665, 5706, 5747, 5788, 5829, 5870, 5911, 5952, 5993, 6034, 6075, 6116, 6157,
    6198, 6239, 6280, 6321, 6361, 6402, 6443, 6484, 6525, 6566, 6607, 6648, 6689, 6730, 6771, 6812, 6853, 6894, 6935,
    6976, 7017, 7058, 7099, 7140, 7181, 7222, 7263, 7304, 7345, 7385, 7426, 7467, 7508, 7549, 7590, 7631, 7672, 7713,
    7754, 7795, 7836, 7877, 7918, 7959, 8000, 8041, 8082, 8123, 8164, 8205, 8246, 8287, 8328, 8369, 8409, 8450, 8491,
    8532, 8573, 8614, 8655, 8696, 8737, 8778, 8819, 8860, 8901, 8942, 8983, 9024
  };
  // 1000: 43840
  // 10000: 412480

  // 120 at 48000 => non-round math
  TransportTester{}.sampleRate(48000).tempo(120).loop(sequencer::Time(1,1,2,0), sequencer::Time(1,1,1,60))
    .check(expected_44800_120);
}

// Transport.nextBatchWithLooping
TEST(Transport, nextBatchWithLooping)
{
  auto start = sequencer::Time(2,1,1,0);
  auto end = sequencer::Time(2,1,1,60);

  std::vector<int> expected_48000_187_5 = {
    61440, 61504, 61568, 61632, 61696, 61760, 61824, 61888, 61952, 62016, 62080, 62144, 62208, 62272, 62336, 62400,
    61503, 61567, 61631, 61695, 61759, 61823, 61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503,
    61567, 61631, 61695, 61759, 61823, 61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567,
    61631, 61695, 61759, 61823, 61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567, 61631,
    61695, 61759, 61823, 61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567, 61631, 61695,
    61759, 61823, 61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567, 61631, 61695, 61759,
    61823, 61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567, 61631, 61695, 61759, 61823,
    61887, 61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567, 61631, 61695, 61759, 61823, 61887,
    61951, 62015, 62079, 62143, 62207, 62271, 62335, 62399, 61503, 61567, 61631, 61695, 61759, 61823, 61887, 61951,
    62015, 62079, 62143, 62207, 62271, 62335, 62399
  };

  TransportTester{}.sampleRate(48000).tempo(187.5).start(start).loop(start, end)
    .check(expected_48000_187_5);

  std::vector<int> expected_48000_120 = {
    61440, 61481, 61522, 61563, 61604, 61645, 61686, 61727, 61768, 61809, 61849, 61890, 61931, 61972, 62013, 62054,
    62095, 62136, 62177, 62218, 62259, 62300, 62341, 62382, 61463, 61504, 61545, 61586, 61627, 61668, 61709, 61750,
    61791, 61832, 61873, 61913, 61954, 61995, 62036, 62077, 62118, 62159, 62200, 62241, 62282, 62323, 62364, 61445,
    61486, 61527, 61568, 61609, 61650, 61691, 61732, 61773, 61814, 61855, 61896, 61937, 61977, 62018, 62059, 62100,
    62141, 62182, 62223, 62264, 62305, 62346, 62387, 61468, 61509, 61550, 61591, 61632, 61673, 61714, 61755, 61796,
    61837, 61878, 61919, 61960, 62001, 62041, 62082, 62123, 62164, 62205, 62246, 62287, 62328, 62369, 61450, 61491,
    61532, 61573, 61614, 61655, 61696, 61737, 61778, 61819, 61860, 61901, 61942, 61983, 62024, 62065, 62105, 62146,
    62187, 62228, 62269, 62310, 62351, 62392, 61473, 61514, 61555, 61596, 61637, 61678, 61719, 61760, 61801, 61842,
    61883, 61924, 61965, 62006, 62047, 62088, 62129, 62169, 62210, 62251, 62292, 62333, 62374, 61455, 61496, 61537,
    61578, 61619, 61660, 61701, 61742, 61783, 61824
  };

  TransportTester{}.sampleRate(48000).tempo(120).start(start).loop(start, end)
    .check(expected_48000_120);

  // this test fails (see nextBatchFailing)
//  std::vector<int> expected_48000_99 = {
//    61440, 61474, 61508, 61542, 61575, 61609, 61643, 61677, 61711, 61744, 61778, 61812, 61846, 61879, 61913, 61947,
//    61981, 62015, 62048, 62082, 62116, 62150, 62184, 62217, 62251, 62285, 62319, 62353, 62386, 61460, 61494, 61528,
//    61562, 61595, 61629, 61663, 61697, 61731, 61764, 61798, 61832, 61866, 61900, 61933, 61967, 62001, 62035, 62068,
//    62102, 62136, 62170, 62204, 62237, 62271, 62305, 62339, 62373, 61447, 61480, 61514, 61548, 61582, 61615, 61649,
//    61683, 61717, 61751, 61784, 61818, 61852, 61886, 61920, 61953, 61987, 62021, 62055, 62089, 62122, 62156, 62190,
//    62224, 62258, 62291, 62325, 62359, 62393, 61467, 61500, 61534, 61568, 61602, 61636, 61669, 61703, 61737, 61771,
//    61804, 61838, 61872, 61906, 61940, 61973, 62007, 62041, 62075, 62109, 62142, 62176, 62210, 62244, 62278, 62311,
//    62345, 62379, 61453, 61487, 61520, 61554, 61588, 61622, 61656, 61689, 61723, 61757, 61791, 61825, 61858, 61892,
//    61926, 61960, 61994, 62027, 62061, 62095, 62129, 62162, 62196, 62230, 62264, 62298, 62331, 62365, 62399, 61473,
//    61507, 61540, 61574, 61608, 61642, 61676, 61709
//  };
//
//  TransportTester{}.sampleRate(48000).tempo(99).start(start).loop(start, end)
//    .check(expected_48000_99);
}


}